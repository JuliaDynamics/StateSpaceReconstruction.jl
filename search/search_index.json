{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"StateSpaceReconstruction.jl documentation This package provides necessarily functionality for the parts of the CausalityTools.jl ecosystem depending on state space reconstruction (SSR), or embeddings. Features Generic embeddings of time series (fully customizable lags and positions). SSR discretization (rectangular binning, simplex triangulations)","title":"Overview"},{"location":"#statespacereconstructionjl-documentation","text":"This package provides necessarily functionality for the parts of the CausalityTools.jl ecosystem depending on state space reconstruction (SSR), or embeddings.","title":"StateSpaceReconstruction.jl documentation"},{"location":"#features","text":"Generic embeddings of time series (fully customizable lags and positions). SSR discretization (rectangular binning, simplex triangulations)","title":"Features"},{"location":"embedding/","text":"Reconstructions/embeddings What are embeddings? If you haven't heard about state space reconstructions (SSR), or embeddings, visit the Wikipedia page on Takens' theorem. Simple examples For those familiar with SSR, performing reconstructions is easy as pie. The constructors accept arrays, vectors of vectors, vectors of SVector , SArray , and Dataset instances from DynamicalSystems.jl . The constructors accept both column-major arrays (points are column vectors) and row-major arrays (points are rows) arrays. Upon embedding, they are all converted to column-major format. First, some trivial examples. julia using StateSpaceReconstruction, StaticArrays, DynamicalSystems Simulate a three-dimensional orbit consisting of 100 points. We'll represent the orbit as a regular array, as an SMatrix and as a Dataset . julia A = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.143569 0.194715 0.519791 0.515948 \u2026 0.771841 0.749099 0.929886 0.716077 0.389791 0.544723 0.995461 0.362778 0.693998 0.265874 0.262664 0.132854 0.00861606 0.757813 0.905783 0.31555 0.448698 julia S = SMatrix{3,100}(A) 3\u00d7100 StaticArrays.SArray{Tuple{3,100},Float64,2,300}: 0.143569 0.194715 0.519791 0.515948 \u2026 0.771841 0.749099 0.929886 0.716077 0.389791 0.544723 0.995461 0.362778 0.693998 0.265874 0.262664 0.132854 0.00861606 0.757813 0.905783 0.31555 0.448698 julia D = Dataset(A) 100-dimensional Dataset{Float64} with 3 points 0.143569 0.194715 0.519791 0.515948 \u2026 0.771841 0.749099 0.929886 0.716077 0.389791 0.544723 0.995461 0.362778 0.693998 0.265874 0.262664 0.132854 0.00861606 0.757813 0.905783 0.31555 0.448698 Embed the raw orbits, performing no coordinate lagging. julia E_A = embed(A) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 100 points Dataset instances from DynamicalSystems.jl can also be embedded. julia E_D = embed(D) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 100 points Instances of SMatrix work just as well. julia E_S = embed(S) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 100 points Verify that all three embeddings are the same, regardless of which data type we're starting from. julia E_A == E_D == E_S true Full control over the embedding One can also specify exactly how the variables of the data should appear in the final embedding, and which embedding lag should be used for each variable. Each variable of the data can appear multiple times in the final embedding with different lags. julia using StateSpaceReconstruction, StaticArrays, DynamicalSystems julia using StateSpaceReconstruction, StaticArrays, DynamicalSystems julia A = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.331512 0.354908 0.394991 0.67605 \u2026 0.850526 0.608729 0.59208 0.493362 0.0636469 0.931318 0.108762 0.283904 0.805373 0.000359184 0.31378 0.441511 0.153857 0.543784 0.0210865 0.173419 0.692074 julia S = SMatrix{3,100}(A) 3\u00d7100 StaticArrays.SArray{Tuple{3,100},Float64,2,300}: 0.331512 0.354908 0.394991 0.67605 \u2026 0.850526 0.608729 0.59208 0.493362 0.0636469 0.931318 0.108762 0.283904 0.805373 0.000359184 0.31378 0.441511 0.153857 0.543784 0.0210865 0.173419 0.692074 julia D = Dataset(A) 100-dimensional Dataset{Float64} with 3 points 0.331512 0.354908 0.394991 0.67605 \u2026 0.850526 0.608729 0.59208 0.493362 0.0636469 0.931318 0.108762 0.283904 0.805373 0.000359184 0.31378 0.441511 0.153857 0.543784 0.0210865 0.173419 0.692074 Embed the orbits, this time using coordinate lagging. Now, let $x$, $y$ and $z$ be variables 1, 2 and 3 of the dataset A . We'll create embeddings of the form $E = {(x(t+1), x(t), y(t), y(t-1), z(t))}$. This means we will have to specify which variable will appear as which variables in the final embedding. julia which_pos = [1, 1, 2, 2, 3] 5-element Array{Int64,1}: 1 1 2 2 3 julia embed_lags = [1, 0, 0, -1, 1] 5-element Array{Int64,1}: 1 0 0 -1 1 Using these positions and lags, we'll get 5-dimensional embeddings. In the plots below, the first three coordinate axes are plotted. julia E_A = embed(A, which_pos, embed_lags) StateSpaceReconstruction.Embeddings.Embedding{5,Float64} with 98 points julia E_D = embed(D, which_pos, embed_lags) StateSpaceReconstruction.Embeddings.Embedding{5,Float64} with 98 points julia E_S = embed(S, which_pos, embed_lags) StateSpaceReconstruction.Embeddings.Embedding{5,Float64} with 98 points Verify that all three embeddings are the same, regardless of which data type we're starting from. julia E_A == E_D == E_S true","title":"Embedding"},{"location":"embedding/#reconstructionsembeddings","text":"","title":"Reconstructions/embeddings"},{"location":"embedding/#what-are-embeddings","text":"If you haven't heard about state space reconstructions (SSR), or embeddings, visit the Wikipedia page on Takens' theorem.","title":"What are embeddings?"},{"location":"embedding/#simple-examples","text":"For those familiar with SSR, performing reconstructions is easy as pie. The constructors accept arrays, vectors of vectors, vectors of SVector , SArray , and Dataset instances from DynamicalSystems.jl . The constructors accept both column-major arrays (points are column vectors) and row-major arrays (points are rows) arrays. Upon embedding, they are all converted to column-major format. First, some trivial examples. julia using StateSpaceReconstruction, StaticArrays, DynamicalSystems Simulate a three-dimensional orbit consisting of 100 points. We'll represent the orbit as a regular array, as an SMatrix and as a Dataset . julia A = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.143569 0.194715 0.519791 0.515948 \u2026 0.771841 0.749099 0.929886 0.716077 0.389791 0.544723 0.995461 0.362778 0.693998 0.265874 0.262664 0.132854 0.00861606 0.757813 0.905783 0.31555 0.448698 julia S = SMatrix{3,100}(A) 3\u00d7100 StaticArrays.SArray{Tuple{3,100},Float64,2,300}: 0.143569 0.194715 0.519791 0.515948 \u2026 0.771841 0.749099 0.929886 0.716077 0.389791 0.544723 0.995461 0.362778 0.693998 0.265874 0.262664 0.132854 0.00861606 0.757813 0.905783 0.31555 0.448698 julia D = Dataset(A) 100-dimensional Dataset{Float64} with 3 points 0.143569 0.194715 0.519791 0.515948 \u2026 0.771841 0.749099 0.929886 0.716077 0.389791 0.544723 0.995461 0.362778 0.693998 0.265874 0.262664 0.132854 0.00861606 0.757813 0.905783 0.31555 0.448698 Embed the raw orbits, performing no coordinate lagging. julia E_A = embed(A) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 100 points Dataset instances from DynamicalSystems.jl can also be embedded. julia E_D = embed(D) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 100 points Instances of SMatrix work just as well. julia E_S = embed(S) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 100 points Verify that all three embeddings are the same, regardless of which data type we're starting from. julia E_A == E_D == E_S true","title":"Simple examples"},{"location":"embedding/#full-control-over-the-embedding","text":"One can also specify exactly how the variables of the data should appear in the final embedding, and which embedding lag should be used for each variable. Each variable of the data can appear multiple times in the final embedding with different lags. julia using StateSpaceReconstruction, StaticArrays, DynamicalSystems julia using StateSpaceReconstruction, StaticArrays, DynamicalSystems julia A = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.331512 0.354908 0.394991 0.67605 \u2026 0.850526 0.608729 0.59208 0.493362 0.0636469 0.931318 0.108762 0.283904 0.805373 0.000359184 0.31378 0.441511 0.153857 0.543784 0.0210865 0.173419 0.692074 julia S = SMatrix{3,100}(A) 3\u00d7100 StaticArrays.SArray{Tuple{3,100},Float64,2,300}: 0.331512 0.354908 0.394991 0.67605 \u2026 0.850526 0.608729 0.59208 0.493362 0.0636469 0.931318 0.108762 0.283904 0.805373 0.000359184 0.31378 0.441511 0.153857 0.543784 0.0210865 0.173419 0.692074 julia D = Dataset(A) 100-dimensional Dataset{Float64} with 3 points 0.331512 0.354908 0.394991 0.67605 \u2026 0.850526 0.608729 0.59208 0.493362 0.0636469 0.931318 0.108762 0.283904 0.805373 0.000359184 0.31378 0.441511 0.153857 0.543784 0.0210865 0.173419 0.692074 Embed the orbits, this time using coordinate lagging. Now, let $x$, $y$ and $z$ be variables 1, 2 and 3 of the dataset A . We'll create embeddings of the form $E = {(x(t+1), x(t), y(t), y(t-1), z(t))}$. This means we will have to specify which variable will appear as which variables in the final embedding. julia which_pos = [1, 1, 2, 2, 3] 5-element Array{Int64,1}: 1 1 2 2 3 julia embed_lags = [1, 0, 0, -1, 1] 5-element Array{Int64,1}: 1 0 0 -1 1 Using these positions and lags, we'll get 5-dimensional embeddings. In the plots below, the first three coordinate axes are plotted. julia E_A = embed(A, which_pos, embed_lags) StateSpaceReconstruction.Embeddings.Embedding{5,Float64} with 98 points julia E_D = embed(D, which_pos, embed_lags) StateSpaceReconstruction.Embeddings.Embedding{5,Float64} with 98 points julia E_S = embed(S, which_pos, embed_lags) StateSpaceReconstruction.Embeddings.Embedding{5,Float64} with 98 points Verify that all three embeddings are the same, regardless of which data type we're starting from. julia E_A == E_D == E_S true","title":"Full control over the embedding"},{"location":"partition/binningtypes/","text":"Binning schemes Currently, there are four types of rectangular partition schemes available, controlled by the parameter \u03f5 : \u03f5::Int divides each axis into \u03f5 intervals of the same size. \u03f5::Float divides each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divides the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divides the i-th axis into intervals of size \u03f5\u1d62 . There are two ways of representing a binning: either by encoding each bin by integers (see Coordinate representation ), or by referencing them by the bin origin coordinates (see Integer encoding representation ). Visualizing partitions To visualize how the different partition schemes work, you can feed the plot_partition a binning scheme \u03f5 along with a three-dimensional set of points. Of course, the partitions also work for data of any dimension. julia using StateSpaceReconstruction, Plots julia pgfplots() Plots.PGFPlotsBackend() julia A = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.209832 0.699465 0.777014 0.0782029 \u2026 0.434489 0.094059 0.622829 0.884307 0.799717 0.177427 0.840316 0.0854936 0.568564 0.392882 0.400403 0.520042 0.731488 0.116754 0.711744 0.400768 0.464859 Rectangular partition constructed by dividing the i-th axis interval into an integer number, \u03f5\u1d62 , of equal-length intervals. julia \u03f5 = [1, 2, 3] 3-element Array{Int64,1}: 1 2 3 julia plot_partition(A, \u03f5); Rectangular partition constructed by dividing the i-th axis into intervals of length \u03f5\u1d62 . julia \u03f5 = [0.1, 0.3, 0.5] 3-element Array{Float64,1}: 0.1 0.3 0.5 julia plot_partition(A, \u03f5); Rectangular partition constructed by dividing all axes into intervals of length \u03f5 . julia \u03f5 = 0.3 0.3 julia plot_partition(A, \u03f5); Rectangular bins, divide all axes into \u03f5 equal-length intervals. julia \u03f5 = 8 8 julia plot_partition(A, \u03f5); Visualizing partitions of embeddings The same works with embeddings. julia A = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.737261 0.380625 0.6893 0.495445 \u2026 0.325793 0.522332 0.933488 0.946574 0.37601 0.906789 0.410474 0.906004 0.723045 0.285312 0.829274 0.0268263 0.154126 0.784413 0.6461 0.392818 0.717565 julia E = embed(A, [1, 2, 3], [1, 0, -5]) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 94 points Rectangular partition constructed by dividing the i-th axis of the embedding interval into an integer number, \u03f5\u1d62 , of equal-length intervals. julia \u03f5 = [1, 2, 3] 3-element Array{Int64,1}: 1 2 3 julia plot_partition(A, \u03f5); Rectangular partition constructed by dividing the i-th axis of the embedding into intervals of length \u03f5\u1d62 . julia \u03f5 = [0.1, 0.3, 0.5] 3-element Array{Float64,1}: 0.1 0.3 0.5 julia plot_partition(A, \u03f5); Rectangular partition constructed by dividing all axes of the embedding into intervals of length \u03f5 . julia \u03f5 = 0.3 0.3 julia plot_partition(A, \u03f5); Rectangular bins, divide all axes of the embedding into \u03f5 equal-length intervals. julia \u03f5 = 8 8 julia plot_partition(A, \u03f5); Customizing visualizations # StateSpaceReconstruction.Partitioning.plot_partition Function . plot_partition(pts::AbstractArray{T, 2}, \u03f5; mc = :blue, ms = 1.5, m\u03b1 = 0.8, lc = :black, lw = 2, ls = :dash, l\u03b1 = 0.6) where T Partition the space defined by pts into rectangular boxes with a binning scheme controlled by \u03f5 . The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The points are assumed to be provided as an array where each point is a column. mc , ms and m\u03b1 control the marker color, marker size and marker opacity, respectively. lc , lw , l\u03b1 and ls control the line color, line width, line opacity and line style, respectively. source plot_partition(E::AbstractEmbedding, \u03f5; vars = [1, 2, 3], mc = :blue, ms = 2, m\u03b1 = 0.8, lc = :black, lw = 2, ls = :dash, l\u03b1 = 0.6) Partition the embedding into rectangular boxes with a binning scheme controlled by \u03f5 . If there are more than three variables in the embedding, you can set which one to use with the vars argument (by default, vars = [1, 2, 3] ). The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . mc , ms and m\u03b1 control the marker color, marker size and marker opacity, respectively. lc , lw , l\u03b1 and ls control the line color, line width, line opacity and line style, respectively. source","title":"Types of partitions"},{"location":"partition/binningtypes/#binning-schemes","text":"Currently, there are four types of rectangular partition schemes available, controlled by the parameter \u03f5 : \u03f5::Int divides each axis into \u03f5 intervals of the same size. \u03f5::Float divides each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divides the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divides the i-th axis into intervals of size \u03f5\u1d62 . There are two ways of representing a binning: either by encoding each bin by integers (see Coordinate representation ), or by referencing them by the bin origin coordinates (see Integer encoding representation ).","title":"Binning schemes"},{"location":"partition/binningtypes/#visualizing-partitions","text":"To visualize how the different partition schemes work, you can feed the plot_partition a binning scheme \u03f5 along with a three-dimensional set of points. Of course, the partitions also work for data of any dimension. julia using StateSpaceReconstruction, Plots julia pgfplots() Plots.PGFPlotsBackend() julia A = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.209832 0.699465 0.777014 0.0782029 \u2026 0.434489 0.094059 0.622829 0.884307 0.799717 0.177427 0.840316 0.0854936 0.568564 0.392882 0.400403 0.520042 0.731488 0.116754 0.711744 0.400768 0.464859 Rectangular partition constructed by dividing the i-th axis interval into an integer number, \u03f5\u1d62 , of equal-length intervals. julia \u03f5 = [1, 2, 3] 3-element Array{Int64,1}: 1 2 3 julia plot_partition(A, \u03f5); Rectangular partition constructed by dividing the i-th axis into intervals of length \u03f5\u1d62 . julia \u03f5 = [0.1, 0.3, 0.5] 3-element Array{Float64,1}: 0.1 0.3 0.5 julia plot_partition(A, \u03f5); Rectangular partition constructed by dividing all axes into intervals of length \u03f5 . julia \u03f5 = 0.3 0.3 julia plot_partition(A, \u03f5); Rectangular bins, divide all axes into \u03f5 equal-length intervals. julia \u03f5 = 8 8 julia plot_partition(A, \u03f5);","title":"Visualizing partitions"},{"location":"partition/binningtypes/#visualizing-partitions-of-embeddings","text":"The same works with embeddings. julia A = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.737261 0.380625 0.6893 0.495445 \u2026 0.325793 0.522332 0.933488 0.946574 0.37601 0.906789 0.410474 0.906004 0.723045 0.285312 0.829274 0.0268263 0.154126 0.784413 0.6461 0.392818 0.717565 julia E = embed(A, [1, 2, 3], [1, 0, -5]) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 94 points Rectangular partition constructed by dividing the i-th axis of the embedding interval into an integer number, \u03f5\u1d62 , of equal-length intervals. julia \u03f5 = [1, 2, 3] 3-element Array{Int64,1}: 1 2 3 julia plot_partition(A, \u03f5); Rectangular partition constructed by dividing the i-th axis of the embedding into intervals of length \u03f5\u1d62 . julia \u03f5 = [0.1, 0.3, 0.5] 3-element Array{Float64,1}: 0.1 0.3 0.5 julia plot_partition(A, \u03f5); Rectangular partition constructed by dividing all axes of the embedding into intervals of length \u03f5 . julia \u03f5 = 0.3 0.3 julia plot_partition(A, \u03f5); Rectangular bins, divide all axes of the embedding into \u03f5 equal-length intervals. julia \u03f5 = 8 8 julia plot_partition(A, \u03f5);","title":"Visualizing partitions of embeddings"},{"location":"partition/binningtypes/#customizing-visualizations","text":"# StateSpaceReconstruction.Partitioning.plot_partition Function . plot_partition(pts::AbstractArray{T, 2}, \u03f5; mc = :blue, ms = 1.5, m\u03b1 = 0.8, lc = :black, lw = 2, ls = :dash, l\u03b1 = 0.6) where T Partition the space defined by pts into rectangular boxes with a binning scheme controlled by \u03f5 . The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The points are assumed to be provided as an array where each point is a column. mc , ms and m\u03b1 control the marker color, marker size and marker opacity, respectively. lc , lw , l\u03b1 and ls control the line color, line width, line opacity and line style, respectively. source plot_partition(E::AbstractEmbedding, \u03f5; vars = [1, 2, 3], mc = :blue, ms = 2, m\u03b1 = 0.8, lc = :black, lw = 2, ls = :dash, l\u03b1 = 0.6) Partition the embedding into rectangular boxes with a binning scheme controlled by \u03f5 . If there are more than three variables in the embedding, you can set which one to use with the vars argument (by default, vars = [1, 2, 3] ). The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . mc , ms and m\u03b1 control the marker color, marker size and marker opacity, respectively. lc , lw , l\u03b1 and ls control the line color, line width, line opacity and line style, respectively. source","title":"Customizing visualizations"},{"location":"partition/coordinate_representation/","text":"Coordinate representation Say we want to impose a rectangular binning on a set of points $x_i$ using a binning scheme specified by \u03f5 . One way of imposing a partition on $x_i$ is to find the minima along each coordinate axis, then finding an N such that $N\\epsilon_i x_i \\leqq (N+1)\\epsilon_i$ if starting from the axis minimum. The marginal coordinate representing the point $x_i$ is then the lower boundary of the box, or $N\\epsilon_i$. Together with the values of \u03f5_i , these coordinates completely specify each box. An alternative representation of the box covering is the Integer encoding representation . # StateSpaceReconstruction.Partitioning.assign_coordinate_labels Method . assign_coordinate_labels(points, \u03f5) - Array{Float64, 2} Consider a rectangular grid specified by \u03f5. Assume the bin labels to the provided points by checking which bins each point fall into. Each points is given a label which is the coordinates of the origin of the bin it falls into. Together with \u03f5 , the coordinates of the origins of the bins provide complete information about a coarse graining that covers all visited states of the system (when points represent the orbit). The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The points are assumed to be provided as an array where each point is a column. source Example julia using StateSpaceReconstruction We'll create a set of random points and bin the space into rectangular boxes with edge lengths $\\epsilon_1 = 0.19, \\epsilon_2 = 0.15, \\epsilon_3 = 0.12$. julia pts = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.290269 0.235897 0.130342 0.443269 \u2026 0.0709061 0.80945 0.549204 0.895393 0.1805 0.719745 0.402763 0.982663 0.765317 0.899384 0.800634 0.362991 0.783647 0.170584 0.877641 0.808859 0.964838 julia \u03f5 = [0.19, 0.15, 0.12] 3-element Array{Float64,1}: 0.19 0.15 0.12 julia assign_coordinate_labels(pts, \u03f5) 3\u00d7100 Array{Float64,2}: 0.196706 0.196706 0.00670608 0.386706 \u2026 0.00670608 0.766706 0.386706 0.892753 0.142753 0.592753 0.292753 0.892753 0.742753 0.892753 0.731608 0.251608 0.731608 0.131608 0.851608 0.731608 0.851608 Each point is now assigned a bin. If a bin has multiple points visiting it, there will be repeated columns. Because this binning was in 3D, we can also visualize it: julia plot_partition(pts, \u03f5) Plot{Plots.PGFPlotsBackend() n=517}","title":"Coordinate representation"},{"location":"partition/coordinate_representation/#coordinate-representation","text":"Say we want to impose a rectangular binning on a set of points $x_i$ using a binning scheme specified by \u03f5 . One way of imposing a partition on $x_i$ is to find the minima along each coordinate axis, then finding an N such that $N\\epsilon_i x_i \\leqq (N+1)\\epsilon_i$ if starting from the axis minimum. The marginal coordinate representing the point $x_i$ is then the lower boundary of the box, or $N\\epsilon_i$. Together with the values of \u03f5_i , these coordinates completely specify each box. An alternative representation of the box covering is the Integer encoding representation . # StateSpaceReconstruction.Partitioning.assign_coordinate_labels Method . assign_coordinate_labels(points, \u03f5) - Array{Float64, 2} Consider a rectangular grid specified by \u03f5. Assume the bin labels to the provided points by checking which bins each point fall into. Each points is given a label which is the coordinates of the origin of the bin it falls into. Together with \u03f5 , the coordinates of the origins of the bins provide complete information about a coarse graining that covers all visited states of the system (when points represent the orbit). The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The points are assumed to be provided as an array where each point is a column. source","title":"Coordinate representation"},{"location":"partition/coordinate_representation/#example","text":"julia using StateSpaceReconstruction We'll create a set of random points and bin the space into rectangular boxes with edge lengths $\\epsilon_1 = 0.19, \\epsilon_2 = 0.15, \\epsilon_3 = 0.12$. julia pts = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.290269 0.235897 0.130342 0.443269 \u2026 0.0709061 0.80945 0.549204 0.895393 0.1805 0.719745 0.402763 0.982663 0.765317 0.899384 0.800634 0.362991 0.783647 0.170584 0.877641 0.808859 0.964838 julia \u03f5 = [0.19, 0.15, 0.12] 3-element Array{Float64,1}: 0.19 0.15 0.12 julia assign_coordinate_labels(pts, \u03f5) 3\u00d7100 Array{Float64,2}: 0.196706 0.196706 0.00670608 0.386706 \u2026 0.00670608 0.766706 0.386706 0.892753 0.142753 0.592753 0.292753 0.892753 0.742753 0.892753 0.731608 0.251608 0.731608 0.131608 0.851608 0.731608 0.851608 Each point is now assigned a bin. If a bin has multiple points visiting it, there will be repeated columns. Because this binning was in 3D, we can also visualize it: julia plot_partition(pts, \u03f5) Plot{Plots.PGFPlotsBackend() n=517}","title":"Example"},{"location":"partition/integer_representation/","text":"Integer encoding representation Say we want to impose a rectangular binning on a set of points $x_i$ using a binning scheme specified by \u03f5 . One way of imposing a partition on $x_i$ is to find the minima along each coordinate axis, then finding an N such that $N\\epsilon_i x_i \\leqq (N+1)\\epsilon_i$ if starting from the axis minimum. The marginal coordinate representing the point $x_i$ is then the $N$ needed to reach the lower boundary of the box. An alternative representation of the box covering is the Coordinate representation . # StateSpaceReconstruction.Partitioning.assign_bin_labels Method . assign_bin_labels(points, \u03f5) Consider a rectangular grid specified by \u03f5. Assign bin labels to the provided points by checking which bins each point fall into. Each points is given a label which is an integer encoding of the origin of the bin it falls into. The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The points are assumed to be provided as an array where each point is a column. source Example julia using StateSpaceReconstruction We'll create a set of random points and bin the space into rectangular boxes with edge lengths $\\epsilon_1 = 0.1, \\epsilon_2 = 0.2, \\epsilon_3 = 0.3$. julia pts = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.825937 0.403895 0.0500535 0.0509912 \u2026 0.105769 0.82882 0.656479 0.718018 0.411264 0.743689 0.139686 0.592288 0.133474 0.967277 0.17341 0.287686 0.573835 0.0900933 0.878389 0.402478 0.465676 julia \u03f5 = [0.1, 0.2, 0.3] 3-element Array{Float64,1}: 0.1 0.2 0.3 julia assign_bin_labels(pts, \u03f5) 3\u00d7100 Array{Int64,2}: 8 4 0 0 7 4 8 5 1 5 3 7 2 \u2026 8 3 9 8 1 8 5 7 7 1 8 6 3 2 3 0 2 2 2 2 4 0 2 2 1 2 1 1 1 3 0 2 1 1 2 0 4 0 0 1 0 1 1 2 0 3 1 0 2 1 0 1 1 0 2 0 2 0 2 2 1 1 Each point is now assigned a bin. If a bin has multiple points visiting it, there will be repeated columns. Because this binning was in 3D, we can also visualize it: julia plot_partition(pts, \u03f5) Plot{Plots.PGFPlotsBackend() n=481}","title":"Integer encoding representation"},{"location":"partition/integer_representation/#integer-encoding-representation","text":"Say we want to impose a rectangular binning on a set of points $x_i$ using a binning scheme specified by \u03f5 . One way of imposing a partition on $x_i$ is to find the minima along each coordinate axis, then finding an N such that $N\\epsilon_i x_i \\leqq (N+1)\\epsilon_i$ if starting from the axis minimum. The marginal coordinate representing the point $x_i$ is then the $N$ needed to reach the lower boundary of the box. An alternative representation of the box covering is the Coordinate representation . # StateSpaceReconstruction.Partitioning.assign_bin_labels Method . assign_bin_labels(points, \u03f5) Consider a rectangular grid specified by \u03f5. Assign bin labels to the provided points by checking which bins each point fall into. Each points is given a label which is an integer encoding of the origin of the bin it falls into. The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The points are assumed to be provided as an array where each point is a column. source","title":"Integer encoding representation"},{"location":"partition/integer_representation/#example","text":"julia using StateSpaceReconstruction We'll create a set of random points and bin the space into rectangular boxes with edge lengths $\\epsilon_1 = 0.1, \\epsilon_2 = 0.2, \\epsilon_3 = 0.3$. julia pts = rand(3, 100) 3\u00d7100 Array{Float64,2}: 0.825937 0.403895 0.0500535 0.0509912 \u2026 0.105769 0.82882 0.656479 0.718018 0.411264 0.743689 0.139686 0.592288 0.133474 0.967277 0.17341 0.287686 0.573835 0.0900933 0.878389 0.402478 0.465676 julia \u03f5 = [0.1, 0.2, 0.3] 3-element Array{Float64,1}: 0.1 0.2 0.3 julia assign_bin_labels(pts, \u03f5) 3\u00d7100 Array{Int64,2}: 8 4 0 0 7 4 8 5 1 5 3 7 2 \u2026 8 3 9 8 1 8 5 7 7 1 8 6 3 2 3 0 2 2 2 2 4 0 2 2 1 2 1 1 1 3 0 2 1 1 2 0 4 0 0 1 0 1 1 2 0 3 1 0 2 1 0 1 1 0 2 0 2 0 2 2 1 1 Each point is now assigned a bin. If a bin has multiple points visiting it, there will be repeated columns. Because this binning was in 3D, we can also visualize it: julia plot_partition(pts, \u03f5) Plot{Plots.PGFPlotsBackend() n=481}","title":"Example"},{"location":"partition/marginal_visitation_frequency/","text":"Marginal visitation frequencies In a system of many variables, it can be useful to find the marginal visitation frequencies after assigning a partition to the set of points. The following function computes marginal visitation frequencies along the coordinate axes specified by along_which_axes for a set of points partitioned into boxes in the manner specified by \u03f5 . Marginal visitation frequencies may also be computed directly from the partition representation of the points in question. Here, visited_bins is the output of either assign_bin_labels or assign_coordinate_labels . In both cases, visitation frequencies are calculated by counting the number of points falling in each bin (i.e. the multiplicity of the bin), then normalizing by the total number of points. # StateSpaceReconstruction.Partitioning.marginal_visitation_freq Function . marginal_visitation_freq(along_which_axes::Union{Int, Vector{Int}, AbstractUnitRange{Int}}, visited_bins::Array{T, 2}) where T Calculate marginal or joint visitation frequencies for a pre-binned set of points. Each column in visited_bins corresponds to a unique point, and contains the coordinate or integer representation of the bin containing that point. Arguments visited_bins : Contains a representation of the boxes containing each point. along_which_axes : Controls which axes to take the marginal visitation frequencies along. Setting along_which_axes to a range 1:D, where D is the dimension of the corresponding state space, corresponds to taking the joint visitation frequency (basically, a D-dimensional histogram). npts : The number of points in the embedding, which is used as a normalization factor. source marginal_visitation_freq( along_which_axes::Union{Int, Vector{Int}, AbstractUnitRange{Int}}, points::Array{T, 2}, \u03f5) where T Compute marginal visitation frequencies for a set of points , given a partition scheme \u03f5 . The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The argument along_which_axes controls which axes to take the marginal visitation frequencies along. Setting along_which_axes to a range 1:D, where D is the dimension of the corresponding state space, corresponds to taking the joint visitation frequency. source marginal_visitation_freq( along_which_axes::Union{Int, Vector{Int}, AbstractUnitRange{Int}}, E::AbstractEmbedding, \u03f5) Compute marginal visitation frequencies for an embedding, given a partition scheme \u03f5 . The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The argument along_which_axes controls which axes to take the marginal visitation frequencies along. Setting along_which_axes to a range 1:D, where D is the dimension of the corresponding state space, corresponds to taking the joint visitation frequency. source Examples julia using StateSpaceReconstruction julia using Plots; pyplot() Plots.PyPlotBackend() \u001b[1m\u001b[33mWARNING: \u001b[39m\u001b[22m\u001b[33mArray(::Type{T}, m::Int) where T is deprecated, use Array{T}(m) instead.\u001b[39m Stacktrace: [1] \u001b[1mdepwarn\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String, ::Symbol\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./deprecated.jl:70\u001b[22m\u001b[22m [2] \u001b[1mArray\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Int64}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./deprecated.jl:57\u001b[22m\u001b[22m [3] \u001b[1mmacro expansion\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/GroupSlices/src/GroupSlices.jl:47\u001b[22m\u001b[22m [inlined] [4] \u001b[1mgroupslices\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Array{Int64,2}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/GroupSlices/src/GroupSlices.jl:34\u001b[22m\u001b[22m [5] \u001b[1mmarginal_visitation_freq\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Int64, ::Array{Int64,2}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/StateSpaceReconstruction/src/partitioning/marginal_visitation_frequency.jl:39\u001b[22m\u001b[22m [6] \u001b[1mmarginal_visitation_freq\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Int64, ::Array{Float64,2}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/StateSpaceReconstruction/src/partitioning/marginal_visitation_frequency.jl:96\u001b[22m\u001b[22m [7] \u001b[1meval\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Module, ::Any\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./boot.jl:235\u001b[22m\u001b[22m [8] \u001b[1mcd\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Expanders.##12#14, ::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./file.jl:70\u001b[22m\u001b[22m [9] \u001b[1m(::Documenter.Utilities.##19#20{Documenter.Expanders.##11#13{Documenter.Documents.Page},Base.TTY,Base.TTY,Pipe,Array{UInt8,1}})\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Utilities/Utilities.jl:591\u001b[22m\u001b[22m [10] \u001b[1mwithoutput\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Expanders.##11#13{Documenter.Documents.Page}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Utilities/Utilities.jl:589\u001b[22m\u001b[22m [11] \u001b[1mrunner\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Expanders.REPLBlocks}, ::Base.Markdown.Code, ::Documenter.Documents.Page, ::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Expanders.jl:536\u001b[22m\u001b[22m [12] \u001b[1mdispatch\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Expanders.ExpanderPipeline}, ::Base.Markdown.Code, ::Vararg{Any,N} where N\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Selectors.jl:168\u001b[22m\u001b[22m [13] \u001b[1mexpand\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Expanders.jl:31\u001b[22m\u001b[22m [14] \u001b[1mrunner\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Builder.ExpandTemplates}, ::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Builder.jl:178\u001b[22m\u001b[22m [15] \u001b[1mdispatch\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document, ::Vararg{Documenter.Documents.Document,N} where N\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Selectors.jl:168\u001b[22m\u001b[22m [16] \u001b[1mcd\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.##2#3{Documenter.Documents.Document}, ::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./file.jl:70\u001b[22m\u001b[22m [17] \u001b[1m#makedocs#1\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Bool, ::Array{Any,1}, ::Function\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Documenter.jl:203\u001b[22m\u001b[22m [18] \u001b[1m(::Documenter.#kw##makedocs)\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Array{Any,1}, ::Documenter.#makedocs\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./ missing :0\u001b[22m\u001b[22m [19] \u001b[1minclude_from_node1\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./loading.jl:576\u001b[22m\u001b[22m [20] \u001b[1minclude\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./sysimg.jl:14\u001b[22m\u001b[22m [21] \u001b[1mprocess_options\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Base.JLOptions\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./client.jl:305\u001b[22m\u001b[22m [22] \u001b[1m_start\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./client.jl:371\u001b[22m\u001b[22m while loading /Users/kristian/Documents/juliapackages/StateSpaceReconstruction/docs/make.jl, in expression starting on line 20 \u001b[1m\u001b[33mWARNING: \u001b[39m\u001b[22m\u001b[33mArray(::Type{T}, m::Int) where T is deprecated, use Array{T}(m) instead.\u001b[39m Stacktrace: [1] \u001b[1mdepwarn\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String, ::Symbol\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./deprecated.jl:70\u001b[22m\u001b[22m [2] \u001b[1mArray\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Array{Int64,1}}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./deprecated.jl:57\u001b[22m\u001b[22m [3] \u001b[1mgroupinds\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Array{Int64,1}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/GroupSlices/src/GroupSlices.jl:131\u001b[22m\u001b[22m [4] \u001b[1mmarginal_visitation_freq\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Int64, ::Array{Int64,2}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/StateSpaceReconstruction/src/partitioning/marginal_visitation_frequency.jl:45\u001b[22m\u001b[22m [5] \u001b[1mmarginal_visitation_freq\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Int64, ::Array{Float64,2}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/StateSpaceReconstruction/src/partitioning/marginal_visitation_frequency.jl:96\u001b[22m\u001b[22m [6] \u001b[1meval\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Module, ::Any\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./boot.jl:235\u001b[22m\u001b[22m [7] \u001b[1mcd\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Expanders.##12#14, ::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./file.jl:70\u001b[22m\u001b[22m [8] \u001b[1m(::Documenter.Utilities.##19#20{Documenter.Expanders.##11#13{Documenter.Documents.Page},Base.TTY,Base.TTY,Pipe,Array{UInt8,1}})\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Utilities/Utilities.jl:591\u001b[22m\u001b[22m [9] \u001b[1mwithoutput\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Expanders.##11#13{Documenter.Documents.Page}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Utilities/Utilities.jl:589\u001b[22m\u001b[22m [10] \u001b[1mrunner\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Expanders.REPLBlocks}, ::Base.Markdown.Code, ::Documenter.Documents.Page, ::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Expanders.jl:536\u001b[22m\u001b[22m [11] \u001b[1mdispatch\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Expanders.ExpanderPipeline}, ::Base.Markdown.Code, ::Vararg{Any,N} where N\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Selectors.jl:168\u001b[22m\u001b[22m [12] \u001b[1mexpand\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Expanders.jl:31\u001b[22m\u001b[22m [13] \u001b[1mrunner\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Builder.ExpandTemplates}, ::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Builder.jl:178\u001b[22m\u001b[22m [14] \u001b[1mdispatch\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document, ::Vararg{Documenter.Documents.Document,N} where N\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Selectors.jl:168\u001b[22m\u001b[22m [15] \u001b[1mcd\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.##2#3{Documenter.Documents.Document}, ::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./file.jl:70\u001b[22m\u001b[22m [16] \u001b[1m#makedocs#1\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Bool, ::Array{Any,1}, ::Function\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Documenter.jl:203\u001b[22m\u001b[22m [17] \u001b[1m(::Documenter.#kw##makedocs)\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Array{Any,1}, ::Documenter.#makedocs\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./ missing :0\u001b[22m\u001b[22m [18] \u001b[1minclude_from_node1\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./loading.jl:576\u001b[22m\u001b[22m [19] \u001b[1minclude\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./sysimg.jl:14\u001b[22m\u001b[22m [20] \u001b[1mprocess_options\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Base.JLOptions\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./client.jl:305\u001b[22m\u001b[22m [21] \u001b[1m_start\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./client.jl:371\u001b[22m\u001b[22m while loading /Users/kristian/Documents/juliapackages/StateSpaceReconstruction/docs/make.jl, in expression starting on line 20 Marginals for one variable at a time Let's create a 5D dataset of 600 points and compute the marginals for each individual coordinate axis, given a partition where each axis is divided into 7 equal-length intervals. julia pts = rand(5, 600) 5\u00d7600 Array{Float64,2}: 0.716971 0.713546 0.379106 \u2026 0.311059 0.66534 0.46219 0.201717 0.0267931 0.962449 0.669575 0.533875 0.0382229 0.608248 0.996294 0.965043 0.349227 0.323862 0.728803 0.604129 0.686137 0.428064 0.215916 0.032772 0.877255 0.094137 0.112072 0.0691378 0.00983208 0.05233 0.126093 julia \u03f5 = 7 7 julia Ms = [marginal_visitation_freq(i, pts, \u03f5) for i = 1:5] 5-element Array{Array{Float64,1},1}: [0.155, 0.2, 0.116667, 0.121667, 0.126667, 0.151667, 0.128333] [0.155, 0.158333, 0.11, 0.145, 0.153333, 0.156667, 0.121667] [0.126667, 0.17, 0.14, 0.148333, 0.125, 0.15, 0.14] [0.148333, 0.16, 0.133333, 0.173333, 0.116667, 0.128333, 0.14] [0.176667, 0.133333, 0.148333, 0.148333, 0.12, 0.153333, 0.12] julia Ms = hcat(Ms...) # convert to array 7\u00d75 Array{Float64,2}: 0.155 0.155 0.126667 0.148333 0.176667 0.2 0.158333 0.17 0.16 0.133333 0.116667 0.11 0.14 0.133333 0.148333 0.121667 0.145 0.148333 0.173333 0.148333 0.126667 0.153333 0.125 0.116667 0.12 0.151667 0.156667 0.15 0.128333 0.153333 0.128333 0.121667 0.14 0.14 0.12 julia heatmap(Ms, xlabel = Coordinate axis # , ylabel = Bin # , size = (300, 500)); Marginals for multiple variables We can also compute the marginals of multiple variables. For this example, choose variables 1:2 , 2:3 and [3, 5] . julia pts = rand(5, 600) 5\u00d7600 Array{Float64,2}: 0.873045 0.254616 0.806245 0.263435 \u2026 0.822108 0.69999 0.0922164 0.687776 0.599364 0.754729 0.707364 0.19168 0.921839 0.0168547 0.490732 0.144141 0.515808 0.131785 0.0289747 0.978598 0.209607 0.142168 0.283087 0.249371 0.0586487 0.524044 0.342304 0.496641 0.149699 0.865308 0.931556 0.739218 0.699596 0.213169 0.375813 julia \u03f5 = 7 7 julia Ms = [marginal_visitation_freq(i, pts, \u03f5) for i = [1:2, 2:3, [3, 5]]] 3-element Array{Array{Float64,1},1}: [0.0166667, 0.015, 0.02, 0.0266667, 0.0183333, 0.0266667, 0.02, 0.0183333, 0.0283333, 0.0266667 \u2026 0.0183333, 0.0216667, 0.0133333, 0.0133333, 0.02, 0.0116667, 0.0166667, 0.0166667, 0.0233333, 0.025] [0.015, 0.025, 0.0233333, 0.0133333, 0.02, 0.0316667, 0.0183333, 0.0216667, 0.0133333, 0.0266667 \u2026 0.0216667, 0.0233333, 0.0216667, 0.0183333, 0.015, 0.03, 0.0166667, 0.015, 0.02, 0.02] [0.02, 0.0216667, 0.0183333, 0.0233333, 0.025, 0.0316667, 0.0166667, 0.0283333, 0.0333333, 0.0266667 \u2026 0.0183333, 0.0166667, 0.0216667, 0.0166667, 0.0216667, 0.015, 0.0183333, 0.0116667, 0.0116667, 0.0166667] julia Ms = hcat(Ms...) # convert to array 49\u00d73 Array{Float64,2}: 0.0166667 0.015 0.02 0.015 0.025 0.0216667 0.02 0.0233333 0.0183333 0.0266667 0.0133333 0.0233333 0.0183333 0.02 0.025 0.0266667 0.0316667 0.0316667 0.02 0.0183333 0.0166667 0.0183333 0.0216667 0.0283333 0.0283333 0.0133333 0.0333333 0.0266667 0.0266667 0.0266667 \u22ee 0.0216667 0.0233333 0.0166667 0.0133333 0.0216667 0.0216667 0.0133333 0.0183333 0.0166667 0.02 0.015 0.0216667 0.0116667 0.03 0.015 0.0166667 0.0166667 0.0183333 0.0166667 0.015 0.0116667 0.0233333 0.02 0.0116667 0.025 0.02 0.0166667 julia heatmap(Ms, xlabel = Coordinate axis # , ylabel = Bin # , size = (300, 500)); Joint visitation frequency Computing the marginals for all available variables corresponds to computing the joint visitation frequency. julia pts = rand(5, 1000) 5\u00d71000 Array{Float64,2}: 0.444848 0.314623 0.552781 0.381632 \u2026 0.643831 0.990346 0.705096 0.427769 0.363053 0.674739 0.313924 0.622124 0.64153 0.566514 0.221862 0.43199 0.148331 0.512499 0.16843 0.477187 0.698726 0.130827 0.423136 0.756523 0.242492 0.0149423 0.197443 0.248123 0.708452 0.847812 0.933985 0.245247 0.32571 0.929911 0.0288952 julia \u03f5 = 2 2 julia jointvisitfreq = marginal_visitation_freq(1:5, pts, \u03f5) 32-element Array{Float64,1}: 0.031 0.037 0.029 0.042 0.029 0.028 0.025 0.03 0.033 0.027 \u22ee 0.027 0.036 0.026 0.041 0.033 0.03 0.031 0.032 0.023 julia bar(jointvisitfreq, size = (400, 500), legend = false) Plot{Plots.PyPlotBackend() n=1} julia xlabel!( State # ); ylabel!( Visitation frequency ); The plot above shows the visitation frequency over the visited bins.","title":"Marginal visitation frequencies"},{"location":"partition/marginal_visitation_frequency/#marginal-visitation-frequencies","text":"In a system of many variables, it can be useful to find the marginal visitation frequencies after assigning a partition to the set of points. The following function computes marginal visitation frequencies along the coordinate axes specified by along_which_axes for a set of points partitioned into boxes in the manner specified by \u03f5 . Marginal visitation frequencies may also be computed directly from the partition representation of the points in question. Here, visited_bins is the output of either assign_bin_labels or assign_coordinate_labels . In both cases, visitation frequencies are calculated by counting the number of points falling in each bin (i.e. the multiplicity of the bin), then normalizing by the total number of points. # StateSpaceReconstruction.Partitioning.marginal_visitation_freq Function . marginal_visitation_freq(along_which_axes::Union{Int, Vector{Int}, AbstractUnitRange{Int}}, visited_bins::Array{T, 2}) where T Calculate marginal or joint visitation frequencies for a pre-binned set of points. Each column in visited_bins corresponds to a unique point, and contains the coordinate or integer representation of the bin containing that point. Arguments visited_bins : Contains a representation of the boxes containing each point. along_which_axes : Controls which axes to take the marginal visitation frequencies along. Setting along_which_axes to a range 1:D, where D is the dimension of the corresponding state space, corresponds to taking the joint visitation frequency (basically, a D-dimensional histogram). npts : The number of points in the embedding, which is used as a normalization factor. source marginal_visitation_freq( along_which_axes::Union{Int, Vector{Int}, AbstractUnitRange{Int}}, points::Array{T, 2}, \u03f5) where T Compute marginal visitation frequencies for a set of points , given a partition scheme \u03f5 . The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The argument along_which_axes controls which axes to take the marginal visitation frequencies along. Setting along_which_axes to a range 1:D, where D is the dimension of the corresponding state space, corresponds to taking the joint visitation frequency. source marginal_visitation_freq( along_which_axes::Union{Int, Vector{Int}, AbstractUnitRange{Int}}, E::AbstractEmbedding, \u03f5) Compute marginal visitation frequencies for an embedding, given a partition scheme \u03f5 . The following \u03f5 will work: \u03f5::Int divide each axis into \u03f5 intervals of the same size. \u03f5::Float divide each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divide the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divide the i-th axis into intervals of size \u03f5\u1d62 . The argument along_which_axes controls which axes to take the marginal visitation frequencies along. Setting along_which_axes to a range 1:D, where D is the dimension of the corresponding state space, corresponds to taking the joint visitation frequency. source","title":"Marginal visitation frequencies"},{"location":"partition/marginal_visitation_frequency/#examples","text":"julia using StateSpaceReconstruction julia using Plots; pyplot() Plots.PyPlotBackend() \u001b[1m\u001b[33mWARNING: \u001b[39m\u001b[22m\u001b[33mArray(::Type{T}, m::Int) where T is deprecated, use Array{T}(m) instead.\u001b[39m Stacktrace: [1] \u001b[1mdepwarn\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String, ::Symbol\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./deprecated.jl:70\u001b[22m\u001b[22m [2] \u001b[1mArray\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Int64}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./deprecated.jl:57\u001b[22m\u001b[22m [3] \u001b[1mmacro expansion\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/GroupSlices/src/GroupSlices.jl:47\u001b[22m\u001b[22m [inlined] [4] \u001b[1mgroupslices\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Array{Int64,2}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/GroupSlices/src/GroupSlices.jl:34\u001b[22m\u001b[22m [5] \u001b[1mmarginal_visitation_freq\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Int64, ::Array{Int64,2}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/StateSpaceReconstruction/src/partitioning/marginal_visitation_frequency.jl:39\u001b[22m\u001b[22m [6] \u001b[1mmarginal_visitation_freq\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Int64, ::Array{Float64,2}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/StateSpaceReconstruction/src/partitioning/marginal_visitation_frequency.jl:96\u001b[22m\u001b[22m [7] \u001b[1meval\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Module, ::Any\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./boot.jl:235\u001b[22m\u001b[22m [8] \u001b[1mcd\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Expanders.##12#14, ::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./file.jl:70\u001b[22m\u001b[22m [9] \u001b[1m(::Documenter.Utilities.##19#20{Documenter.Expanders.##11#13{Documenter.Documents.Page},Base.TTY,Base.TTY,Pipe,Array{UInt8,1}})\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Utilities/Utilities.jl:591\u001b[22m\u001b[22m [10] \u001b[1mwithoutput\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Expanders.##11#13{Documenter.Documents.Page}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Utilities/Utilities.jl:589\u001b[22m\u001b[22m [11] \u001b[1mrunner\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Expanders.REPLBlocks}, ::Base.Markdown.Code, ::Documenter.Documents.Page, ::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Expanders.jl:536\u001b[22m\u001b[22m [12] \u001b[1mdispatch\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Expanders.ExpanderPipeline}, ::Base.Markdown.Code, ::Vararg{Any,N} where N\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Selectors.jl:168\u001b[22m\u001b[22m [13] \u001b[1mexpand\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Expanders.jl:31\u001b[22m\u001b[22m [14] \u001b[1mrunner\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Builder.ExpandTemplates}, ::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Builder.jl:178\u001b[22m\u001b[22m [15] \u001b[1mdispatch\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document, ::Vararg{Documenter.Documents.Document,N} where N\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Selectors.jl:168\u001b[22m\u001b[22m [16] \u001b[1mcd\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.##2#3{Documenter.Documents.Document}, ::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./file.jl:70\u001b[22m\u001b[22m [17] \u001b[1m#makedocs#1\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Bool, ::Array{Any,1}, ::Function\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Documenter.jl:203\u001b[22m\u001b[22m [18] \u001b[1m(::Documenter.#kw##makedocs)\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Array{Any,1}, ::Documenter.#makedocs\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./ missing :0\u001b[22m\u001b[22m [19] \u001b[1minclude_from_node1\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./loading.jl:576\u001b[22m\u001b[22m [20] \u001b[1minclude\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./sysimg.jl:14\u001b[22m\u001b[22m [21] \u001b[1mprocess_options\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Base.JLOptions\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./client.jl:305\u001b[22m\u001b[22m [22] \u001b[1m_start\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./client.jl:371\u001b[22m\u001b[22m while loading /Users/kristian/Documents/juliapackages/StateSpaceReconstruction/docs/make.jl, in expression starting on line 20 \u001b[1m\u001b[33mWARNING: \u001b[39m\u001b[22m\u001b[33mArray(::Type{T}, m::Int) where T is deprecated, use Array{T}(m) instead.\u001b[39m Stacktrace: [1] \u001b[1mdepwarn\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String, ::Symbol\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./deprecated.jl:70\u001b[22m\u001b[22m [2] \u001b[1mArray\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Array{Int64,1}}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./deprecated.jl:57\u001b[22m\u001b[22m [3] \u001b[1mgroupinds\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Array{Int64,1}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/GroupSlices/src/GroupSlices.jl:131\u001b[22m\u001b[22m [4] \u001b[1mmarginal_visitation_freq\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Int64, ::Array{Int64,2}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/StateSpaceReconstruction/src/partitioning/marginal_visitation_frequency.jl:45\u001b[22m\u001b[22m [5] \u001b[1mmarginal_visitation_freq\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Int64, ::Array{Float64,2}, ::Int64\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/StateSpaceReconstruction/src/partitioning/marginal_visitation_frequency.jl:96\u001b[22m\u001b[22m [6] \u001b[1meval\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Module, ::Any\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./boot.jl:235\u001b[22m\u001b[22m [7] \u001b[1mcd\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Expanders.##12#14, ::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./file.jl:70\u001b[22m\u001b[22m [8] \u001b[1m(::Documenter.Utilities.##19#20{Documenter.Expanders.##11#13{Documenter.Documents.Page},Base.TTY,Base.TTY,Pipe,Array{UInt8,1}})\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Utilities/Utilities.jl:591\u001b[22m\u001b[22m [9] \u001b[1mwithoutput\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Expanders.##11#13{Documenter.Documents.Page}\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Utilities/Utilities.jl:589\u001b[22m\u001b[22m [10] \u001b[1mrunner\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Expanders.REPLBlocks}, ::Base.Markdown.Code, ::Documenter.Documents.Page, ::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Expanders.jl:536\u001b[22m\u001b[22m [11] \u001b[1mdispatch\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Expanders.ExpanderPipeline}, ::Base.Markdown.Code, ::Vararg{Any,N} where N\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Selectors.jl:168\u001b[22m\u001b[22m [12] \u001b[1mexpand\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Expanders.jl:31\u001b[22m\u001b[22m [13] \u001b[1mrunner\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Builder.ExpandTemplates}, ::Documenter.Documents.Document\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Builder.jl:178\u001b[22m\u001b[22m [14] \u001b[1mdispatch\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document, ::Vararg{Documenter.Documents.Document,N} where N\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Selectors.jl:168\u001b[22m\u001b[22m [15] \u001b[1mcd\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Documenter.##2#3{Documenter.Documents.Document}, ::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./file.jl:70\u001b[22m\u001b[22m [16] \u001b[1m#makedocs#1\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Bool, ::Array{Any,1}, ::Function\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m/Users/kristian/.julia/v0.6/Documenter/src/Documenter.jl:203\u001b[22m\u001b[22m [17] \u001b[1m(::Documenter.#kw##makedocs)\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Array{Any,1}, ::Documenter.#makedocs\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./ missing :0\u001b[22m\u001b[22m [18] \u001b[1minclude_from_node1\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./loading.jl:576\u001b[22m\u001b[22m [19] \u001b[1minclude\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::String\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./sysimg.jl:14\u001b[22m\u001b[22m [20] \u001b[1mprocess_options\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m::Base.JLOptions\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./client.jl:305\u001b[22m\u001b[22m [21] \u001b[1m_start\u001b[22m\u001b[22m\u001b[1m(\u001b[22m\u001b[22m\u001b[1m)\u001b[22m\u001b[22m at \u001b[1m./client.jl:371\u001b[22m\u001b[22m while loading /Users/kristian/Documents/juliapackages/StateSpaceReconstruction/docs/make.jl, in expression starting on line 20","title":"Examples"},{"location":"partition/marginal_visitation_frequency/#marginals-for-one-variable-at-a-time","text":"Let's create a 5D dataset of 600 points and compute the marginals for each individual coordinate axis, given a partition where each axis is divided into 7 equal-length intervals. julia pts = rand(5, 600) 5\u00d7600 Array{Float64,2}: 0.716971 0.713546 0.379106 \u2026 0.311059 0.66534 0.46219 0.201717 0.0267931 0.962449 0.669575 0.533875 0.0382229 0.608248 0.996294 0.965043 0.349227 0.323862 0.728803 0.604129 0.686137 0.428064 0.215916 0.032772 0.877255 0.094137 0.112072 0.0691378 0.00983208 0.05233 0.126093 julia \u03f5 = 7 7 julia Ms = [marginal_visitation_freq(i, pts, \u03f5) for i = 1:5] 5-element Array{Array{Float64,1},1}: [0.155, 0.2, 0.116667, 0.121667, 0.126667, 0.151667, 0.128333] [0.155, 0.158333, 0.11, 0.145, 0.153333, 0.156667, 0.121667] [0.126667, 0.17, 0.14, 0.148333, 0.125, 0.15, 0.14] [0.148333, 0.16, 0.133333, 0.173333, 0.116667, 0.128333, 0.14] [0.176667, 0.133333, 0.148333, 0.148333, 0.12, 0.153333, 0.12] julia Ms = hcat(Ms...) # convert to array 7\u00d75 Array{Float64,2}: 0.155 0.155 0.126667 0.148333 0.176667 0.2 0.158333 0.17 0.16 0.133333 0.116667 0.11 0.14 0.133333 0.148333 0.121667 0.145 0.148333 0.173333 0.148333 0.126667 0.153333 0.125 0.116667 0.12 0.151667 0.156667 0.15 0.128333 0.153333 0.128333 0.121667 0.14 0.14 0.12 julia heatmap(Ms, xlabel = Coordinate axis # , ylabel = Bin # , size = (300, 500));","title":"Marginals for one variable at a time"},{"location":"partition/marginal_visitation_frequency/#marginals-for-multiple-variables","text":"We can also compute the marginals of multiple variables. For this example, choose variables 1:2 , 2:3 and [3, 5] . julia pts = rand(5, 600) 5\u00d7600 Array{Float64,2}: 0.873045 0.254616 0.806245 0.263435 \u2026 0.822108 0.69999 0.0922164 0.687776 0.599364 0.754729 0.707364 0.19168 0.921839 0.0168547 0.490732 0.144141 0.515808 0.131785 0.0289747 0.978598 0.209607 0.142168 0.283087 0.249371 0.0586487 0.524044 0.342304 0.496641 0.149699 0.865308 0.931556 0.739218 0.699596 0.213169 0.375813 julia \u03f5 = 7 7 julia Ms = [marginal_visitation_freq(i, pts, \u03f5) for i = [1:2, 2:3, [3, 5]]] 3-element Array{Array{Float64,1},1}: [0.0166667, 0.015, 0.02, 0.0266667, 0.0183333, 0.0266667, 0.02, 0.0183333, 0.0283333, 0.0266667 \u2026 0.0183333, 0.0216667, 0.0133333, 0.0133333, 0.02, 0.0116667, 0.0166667, 0.0166667, 0.0233333, 0.025] [0.015, 0.025, 0.0233333, 0.0133333, 0.02, 0.0316667, 0.0183333, 0.0216667, 0.0133333, 0.0266667 \u2026 0.0216667, 0.0233333, 0.0216667, 0.0183333, 0.015, 0.03, 0.0166667, 0.015, 0.02, 0.02] [0.02, 0.0216667, 0.0183333, 0.0233333, 0.025, 0.0316667, 0.0166667, 0.0283333, 0.0333333, 0.0266667 \u2026 0.0183333, 0.0166667, 0.0216667, 0.0166667, 0.0216667, 0.015, 0.0183333, 0.0116667, 0.0116667, 0.0166667] julia Ms = hcat(Ms...) # convert to array 49\u00d73 Array{Float64,2}: 0.0166667 0.015 0.02 0.015 0.025 0.0216667 0.02 0.0233333 0.0183333 0.0266667 0.0133333 0.0233333 0.0183333 0.02 0.025 0.0266667 0.0316667 0.0316667 0.02 0.0183333 0.0166667 0.0183333 0.0216667 0.0283333 0.0283333 0.0133333 0.0333333 0.0266667 0.0266667 0.0266667 \u22ee 0.0216667 0.0233333 0.0166667 0.0133333 0.0216667 0.0216667 0.0133333 0.0183333 0.0166667 0.02 0.015 0.0216667 0.0116667 0.03 0.015 0.0166667 0.0166667 0.0183333 0.0166667 0.015 0.0116667 0.0233333 0.02 0.0116667 0.025 0.02 0.0166667 julia heatmap(Ms, xlabel = Coordinate axis # , ylabel = Bin # , size = (300, 500));","title":"Marginals for multiple variables"},{"location":"partition/marginal_visitation_frequency/#joint-visitation-frequency","text":"Computing the marginals for all available variables corresponds to computing the joint visitation frequency. julia pts = rand(5, 1000) 5\u00d71000 Array{Float64,2}: 0.444848 0.314623 0.552781 0.381632 \u2026 0.643831 0.990346 0.705096 0.427769 0.363053 0.674739 0.313924 0.622124 0.64153 0.566514 0.221862 0.43199 0.148331 0.512499 0.16843 0.477187 0.698726 0.130827 0.423136 0.756523 0.242492 0.0149423 0.197443 0.248123 0.708452 0.847812 0.933985 0.245247 0.32571 0.929911 0.0288952 julia \u03f5 = 2 2 julia jointvisitfreq = marginal_visitation_freq(1:5, pts, \u03f5) 32-element Array{Float64,1}: 0.031 0.037 0.029 0.042 0.029 0.028 0.025 0.03 0.033 0.027 \u22ee 0.027 0.036 0.026 0.041 0.033 0.03 0.031 0.032 0.023 julia bar(jointvisitfreq, size = (400, 500), legend = false) Plot{Plots.PyPlotBackend() n=1} julia xlabel!( State # ); ylabel!( Visitation frequency ); The plot above shows the visitation frequency over the visited bins.","title":"Joint visitation frequency"},{"location":"partition/minima_stepsizes/","text":"To assign boxes to points, we need a reference point. Throughout this package, the minima along each coordinate axis of the space is used as the reference point. The following function takes a set of points and a binning scheme \u03f5 , and returns what the minima along each coordinate axis is, along with the step sizes along each axis resulting from the binning scheme provided by \u03f5 . # StateSpaceReconstruction.Partitioning.minima_and_stepsizes Method . minima_and_stepsizes(points, \u03f5) - (Vector{Float}, Vector{Float}) Find the minima along each axis of the embedding, and computes appropriate stepsizes given \u03f5 , which provide instructions on how to grid the space. Assumes each point is a column vector. Specifically, the binning procedure is controlled by the type of \u03f5 : \u03f5::Int divides each axis into \u03f5 intervals of the same size. \u03f5::Float divides each axis into intervals of size \u03f5 . \u03f5::Vector{Int} divides the i-th axis into \u03f5\u1d62 intervals of the same size. \u03f5::Vector{Float64} divides the i-th axis into intervals of size \u03f5\u1d62 . source","title":"Axis minima and step sizes"},{"location":"simplexpartition/simplex/","text":"Simplex partitions Simplex partitions are formed by performing a Delaunay triangulation of the points, forming a set of disjoint simplices entirely covering the point cloud. Example julia using StateSpaceReconstruction julia using Plots Create a set of random points (just a few, so it doesn't take forever to plot the triangulation), and triangulate them. julia E = embed(rand(3, 20)) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 20 points julia tri = delaunaytriang(E) StateSpaceReconstruction.DelaunayTriangulation(Int32[13 14 \u2026 19 19; 9 12 \u2026 8 3; 17 20 \u2026 1 1; 18 6 \u2026 5 5]) julia plot_triang(E, tri, vertices = true);","title":"Overview"},{"location":"simplexpartition/simplex/#simplex-partitions","text":"Simplex partitions are formed by performing a Delaunay triangulation of the points, forming a set of disjoint simplices entirely covering the point cloud.","title":"Simplex partitions"},{"location":"simplexpartition/simplex/#example","text":"julia using StateSpaceReconstruction julia using Plots Create a set of random points (just a few, so it doesn't take forever to plot the triangulation), and triangulate them. julia E = embed(rand(3, 20)) StateSpaceReconstruction.Embeddings.Embedding{3,Float64} with 20 points julia tri = delaunaytriang(E) StateSpaceReconstruction.DelaunayTriangulation(Int32[13 14 \u2026 19 19; 9 12 \u2026 8 3; 17 20 \u2026 1 1; 18 6 \u2026 5 5]) julia plot_triang(E, tri, vertices = true);","title":"Example"}]}